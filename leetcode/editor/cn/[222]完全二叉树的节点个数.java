//ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚ 
//
// å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚
//ä¸ºç¬¬ h å±‚ï¼ˆä»ç¬¬ 0 å±‚å¼€å§‹ï¼‰ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2Ê° ä¸ªèŠ‚ç‚¹ã€‚ 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
// 
// 
//è¾“å…¥ï¼šroot = [1,2,3,4,5,6]
//è¾“å‡ºï¼š6
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šroot = []
//è¾“å‡ºï¼š0
// 
//
// ç¤ºä¾‹ 3ï¼š 
//
// 
//è¾“å…¥ï¼šroot = [1]
//è¾“å‡ºï¼š1
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯[0, 5 * 10â´] 
// 0 <= Node.val <= 5 * 10â´ 
// é¢˜ç›®æ•°æ®ä¿è¯è¾“å…¥çš„æ ‘æ˜¯ å®Œå…¨äºŒå‰æ ‘ 
// 
//
// 
//
// è¿›é˜¶ï¼šéå†æ ‘æ¥ç»Ÿè®¡èŠ‚ç‚¹æ˜¯ä¸€ç§æ—¶é—´å¤æ‚åº¦ä¸º O(n) çš„ç®€å•è§£å†³æ–¹æ¡ˆã€‚ä½ å¯ä»¥è®¾è®¡ä¸€ä¸ªæ›´å¿«çš„ç®—æ³•å—ï¼Ÿ 
//
// Related Topics ä½è¿ç®— æ ‘ äºŒåˆ†æŸ¥æ‰¾ äºŒå‰æ ‘ ğŸ‘ 1208 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }

        var h = 0;
        TreeNode cur = root;
        while (cur.left != null) {
            h++;
            cur = cur.left;
        }

        int min = (1 << h);
        int max = (1 << (h + 1)) - 1;

        int ans = min;
        while (min <= max) {
            int mid = (min + max) / 2;
            if (checkNodeExisted(mid, root, h)) {
                ans = mid;
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }

        return ans;
    }

    private boolean checkNodeExisted(int mid, TreeNode root, int h) {
        int lastLevelLeaf = mid - (1 << h) + 1;
        int sub = 1 << (h - 1);
        while (sub > 0) {
            if (lastLevelLeaf > sub) {
                if (root.right == null) {
                    return false;
                }
                lastLevelLeaf -= sub;
                root = root.right;
            } else {
                if (root.left == null) {
                    return false;
                }
                root = root.left;
            }

            sub = (sub >> 1);
        }

        return true;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3, new TreeNode(6), null));

//        System.out.println(new Solution().checkNodeExisted(4, root, 2));
//        System.out.println(new Solution().checkNodeExisted(5, root, 2));
//        System.out.println(new Solution().checkNodeExisted(6, root, 2));
//        System.out.println(!new Solution().checkNodeExisted(7, root, 2));


        System.out.println(new Solution().countNodes(root));
    }
}
//leetcode submit region end(Prohibit modification and deletion)
